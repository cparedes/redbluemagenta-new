--- 
layout: post
title: "Solutions to Project Euler Problems #1 and #2"
post_id: "114"
categories:
- Math
- Programming
- Project Euler
---
Site: <a href="http://projecteuler.net/">http://projecteuler.net/</a>

I'm not sure if I'm going to publish any more after this, mostly because the whole point of solving the problems on the site is to learn some stuff about math and computer science, and so it'll be to everyone's benefit if I don't publish every solution I find.

Anyway, here's problem #1.  I'll be writing my code in really rough pseudocode:

<blockquote>PROBLEM #1: If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.</blockquote>

We notice that if we divide evenly into a number <em>n</em> with say an integer <em>k</em>, we end up with no remainder.  So in order to check to see if <em>n</em> is divided evenly by <em>k</em>, we use the modulo operator and see if it's 0.  In this case, we want to check against <em>k</em> = 3 and <em>k</em> = 5.  If we find that <em>n</em> mod <em>k</em> is equal to 0, then we want to store <em>n</em> in a list of numbers that we want to keep for ourselves.

<pre><code>if n mod 3 == 0, then add number to the list of numbers that will be summed up.
if n mod 5 == 0, then add number to the list of numbers that will be summed up.
if n mod 5 != 0 && n mod 3 != 0, then _don't_ add number to the list.</code></pre>

What's wrong with the code above?  We want to make sure that we don't add a number twice to the list if the number is both divided evenly by 3 and 5 (like the number 15.)  We could always just add another if statement that catches the case where 3 and 5 both evenly divide <em>n</em>, but I'm taking another approach: we add an additional variable to the code and tweak our if statement a little bit:

<pre><code>pushToList = 0
if n mod 3 == 0, pushToList = 1.
if n mod 5 == 0, pushToList = 1.
if pushToList == 1, push n to the end of the list.</code></pre>

We embed this in a loop such that the iterator goes from 1 to 999:

<pre><code>for i in (1..999)
pushToList = 0
if i mod 3 == 0, pushToList = 1.
if i mod 5 == 0, pushToList = 1.
if pushToList == 1, push n to the end of the list.
end
</code></pre>

Then we spit out the sum of the list.

<pre><code>for each element in list,
sum += element
end
display "sum"
</code></pre>

Alright, that's done.  Here's problem #2.  This is a little harder, since we have to worry about performance optimization:

<blockquote>PROBLEM #2: Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

<center>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</center>

Find the sum of all the even-valued terms in the sequence which do not exceed four million.</blockquote>

The Fibonacci sequence is the sum of the last two terms in the sequence, with the first two terms set to 1.  In the example above, the author decides to start with 1 and 2, but we can stick with the usual definition, where <em>F</em>(1) = 1, <em>F</em>(2) = 1, and <em>F</em>(n) = <em>F</em>(n - 1) + <em>F</em>(n - 2).

Our main body of the code should look something like this:

<pre><code>while fibTemp < 4000000
fibTemp = F(i)
if (F(i) mod 2 == 0), push F(i) to the list of numbers to be added
end

F(n) {
if n <= 2, return 1
return F(n - 1) + F(n - 2)
}</code></pre>

However, this is extremely inefficient.  Look at <em>F</em>(5) = <em>F</em>(4) + <em>F</em>(3): <em>F</em>(4) is also equal to <em>F</em>(3) + <em>F</em>(2), and once we're done calculating <em>F</em>(4), we've already calculated <em>F</em>(3), but we have to recalculate <em>F</em>(3) on the other side of the recursive equation anyway.

Since I'm a lazy bastard, I pulled up the <a href="http://en.wikipedia.org/wiki/Fibonacci_sequence">Wikipedia page for the Fibonacci Sequence</a>, and observed that we can express the <em>n</em>th term of the sequence in the following form:

<center>[latex]\left( \begin{array}{cc}1 & 1 \\ 1 & 0 \end{array} \right)^{n-1} = \left( \begin{array}{cc}F_n & F_{n-1} \\ F_{n-1} & F_{n-2} \end{array} \right)[/latex]</center>

Therefore, if we iterated the first matrix <em>n - 1</em> times, then we can read off the <em>n</em>th term in the (0,0)th spot in the resulting matrix.

Can we do better than this?  We notice that when we calculate the <em>n</em>th term in the Fibonacci sequence, we have to multiply the matrix <em>n - 1</em> times; this means that for the <em>n+1</em>th term, we redo our multiplication <em>n - 1</em> times, times another matrix; this results in wasted CPU cycles.  And so, instead of using a built in function to calculate an arbitrary exponentiation of a matrix, we'd want to store the last matrix calculated and then multiply that with the first matrix.

<pre><code>M = ( (1, 1), (1, 0) )
cachedMatrix = M
sum = 0

while (cachedMatrix.coordinate(0,0) < 4000000)
cachedMatrix *= M
array.push cachedMatrix.coordinate(0,0) if cachedMatrix.coordinate(0,0) mod 2 == 0
end

for each element in array
sum += array[element]
end

display "sum"</code></pre>

I'm sure there's a faster solution than that which only uses integer scalars in a loop (a friend of mine, Paul Wallstrom, has a decent solution as well); however, this should solve #2 as well.
